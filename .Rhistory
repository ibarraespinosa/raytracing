vg0 <- calcVg(betamz = betamz, Ks2 = Ks2_y0, y = y0, lat = lat,
K = K, direction = direction)
y1 <- y0 + dt*vg0
Ks2_y1 <- betamz[ypos(y1, lat = lat)] / umz[ypos(y1, lat = lat)]
l2_y1 <- Ks2_y1 - k2
# Stationary Rossby waves are only possible for beta >=0 & U > 0 (Hoskins & Ambrizzi, 1993):
# C2: Ks2 = k2 --> l2 = 0
# C3 & C4: Ks2 < k2 --> l2 < 0
if(Ks2_y1  < 0 ) {
message(paste0("Stationary Rossby waves are only " ,
"possible for beta >=0 & U > 0 (HA1993). \n",
"Ks2 = ", Ks2_y1,"\n",
"l2 = ", l2_y1,"\n",
"l2[count-1] = ", l_l2_y1[count-1],"\n",
"Leaving parent while loop 1"))
break
}
# Write the elements at y0 on the lists
l_time[[count]] <- count
l_y0[[count]] <- ypos(y0, lat = lat)
l_lon_x0[[count]] <- x0
l_lat_y0[[count]] <- y0
l_tun_y0[[count]] <- ifelse(l2_y0 <= 0, -1, 1)
l_l2_y0[[count]] <- l2_y0
l_Ks2_y0[[count]] <- Ks2_y0
l_betamz_y0[[count]] <- betamz[ypos(y0, lat = lat)]
l_umz_y0[[count]] <- umz[ypos(y0, lat = lat)]
# Write the elements at y1 on the lists before test the turning latitude in y0
l_y1[[count]] <- ypos(y1, lat = lat)
l_lat_y1[[count]] <- y1
l_tun_y1[[count]] <- ifelse(l2_y1 <= 0, -1, 1)
l_l2_y1[[count]] <- l2_y1
l_Ks2_y1[[count]] <- Ks2_y1
l_betamz_y1[[count]] <- betamz[ypos(y1, lat = lat)]
l_umz_y1[[count]] <- umz[ypos(y1, lat = lat)]
ug1 <- calcUg(betamz = betamz, Ks2 = Ks2_y1, y = y1, lat = lat)
vg1 <- calcVg(betamz = betamz, Ks2 = Ks2_y1, y = y1, lat = lat,
K = K, direction = direction)
x2 <- x0 + 0.5*dt*(ug0+ug1)
y2 <- y0 + 0.5*dt*(vg0+vg1)
x0 <- x2
y0 <- y2
if(count == itime) {
message("itime reached \n",
"Leaving parent while loop 1\n")
break
}
}
# Store data before turning latitude
dff <- data.frame(K = rep(K, length(unlist(l_time))),
x_ini = rep(x_ini, length(unlist(l_time))),
y_ini = rep(y_ini, length(unlist(l_time))),
direction = rep(direction, length(unlist(l_time))),
time = unlist(l_time),
x0 = unlist(l_lon_x0),
y0 = unlist(l_lat_y0),
y1 = unlist(l_lat_y1),
ilat_y0 = unlist(l_y0),
ilat_y1 = unlist(l_y1),
tun_y0 = unlist(l_tun_y0),
tun_y1 = unlist(l_tun_y1),
l2_y0 = unlist(l_l2_y0),
l2_y1 = unlist(l_l2_y1),
l2_y0_rounded = round(unlist(l_l2_y0), 13),
l2_y1_rounded = round(unlist(l_l2_y1), 13),
Ks2_y0 = unlist(l_Ks2_y0),
Ks2_y1 = unlist(l_Ks2_y1),
betamz_y0 = unlist(l_betamz_y0),
betamz_y1 = unlist(l_betamz_y1),
umz_y0 = unlist(l_umz_y0),
umz_y1 = unlist(l_umz_y1))
dff$id <- 1:nrow(dff)
# dff <- dff[-dff$id[14:19],]
# write.csv(x = dff, "K3_antes_tl.csv", row.names = FALSE)
# Initial conditions for while loop parent 2 (after turning point)
x0 <- dff[max(dff$id),]$x0
y0 <- dff[max(dff$id),]$y0
count <- dff[max(dff$id),]$time
cat(paste0("Restarting from the turning...\n",
"longitude x0 = ", round(x0, 3), "\n",
"latitude  y0 = " , round(y0, 3), "\n",
"iteration    =  ", count, "\n"))
l_time   <- list()
l_lon_x0 <- list()
l_lat_y0 <- list()
l_y0     <- list()
l_tun_y0 <- list()
l_l2_y0 <- list()
l_Ks2_y0  <- list()
l_betamz_y0 <- list()
l_umz_y0 <- list()
l_lon_x1 <- list()
l_lat_y1 <- list()
l_y1     <- list()
l_tun_y1 <- list()
l_l2_y1 <- list()
l_Ks2_y1  <- list()
l_betamz_y1 <- list()
l_umz_y1 <- list()
# Beginning of the while loop parent 2 ####
while(TRUE) {
count <- count + 1
cat("count    =  ", count, "\n")
if(verbose) {
cat(paste0("Iteration: ", count,
"   ypos: ", ypos(y0, lat = lat), " -->  lat y0:", round(y0, 2), "\n"))
}
Ks2_y0 <- betamz[ypos(y0, lat)]/umz[ypos(y0, lat)]
l2_y0 <- Ks2_y0 - k2
# Stationary Rossby waves are only possible for beta >=0 & U > 0 (Hoskins & Ambrizzi, 1993):
# C2: Ks2 = k2 --> l2 = 0
# if(round(l2_y0, rd) == 0){
#
#   message("Ks2 = k2 --> l2_y0 = ", round(l2_y0, rd), "\n",
#           "Leaving parent while loop 1\n")
#
#   l_time[[count]] <- count
#   l_y0[[count]] <- ypos(y0, lat = lat)
#   l_lon_x0[[count]] <- x0
#   l_lat_y0[[count]] <- y0
#   l_tun_y0[[count]] <- ifelse(l2_y0 <= 0, -1, 1)
#   l_l2_y0[[count]] <- l2_y0
#   l_Ks2_y0[[count]] <- Ks2_y0
#   l_betamz_y0[[count]] <- betamz[ypos(y0, lat = lat)]
#   l_umz_y0[[count]] <- umz[ypos(y0, lat = lat)]
#
#   l_y1[[count]] <- NA
#   l_lat_y1[[count]] <- NA
#   l_tun_y1[[count]] <- NA
#   l_l2_y1[[count]] <- NA
#   l_Ks2_y1[[count]] <- NA
#   l_betamz_y1[[count]] <- NA
#   l_umz_y1[[count]] <- NA
#
#   break
# }
# C3 & C4: Ks2 < k2 --> l2 < 0
if(Ks2_y0 < 0 ) {
message(paste0("Stationary Rossby waves are only " ,
"possible for beta >=0 & U > 0 (HA1993). \n",
"Ks2 = ", Ks2_y0,"\n",
"Leaving parent while loop 2\n"))
break
}
ug0 <- calcUg(betamz = betamz, Ks2 = Ks2_y0, y = y0, lat = lat)
vg0 <- calcVg(betamz = betamz, Ks2 = Ks2_y0, y = y0, lat = lat,
K = K, direction = direction, tl = -1)
y1 <- y0 + dt*vg0
Ks2_y1 <- betamz[ypos(y1, lat = lat)] / umz[ypos(y1, lat = lat)]
l2_y1 <- Ks2_y1 - k2
# Stationary Rossby waves are only possible for beta >=0 & U > 0 (Hoskins & Ambrizzi, 1993):
# C2: Ks2 = k2 --> l2 = 0
# if(round(l2_y1, rd) == 0){
#   message("Ks2 = k2 --> l2_y1 = ", round(l2_y1, rd), "\n",
#           "Leaving parent while loop 1\n")
#
#   l_time[[count]] <- count
#   l_y0[[count]] <- ypos(y0, lat = lat)
#   l_lon_x0[[count]] <- x0
#   l_lat_y0[[count]] <- y0
#   l_tun_y0[[count]] <- ifelse(l2_y0 <= 0, -1, 1)
#   l_l2_y0[[count]] <- l2_y0
#   l_Ks2_y0[[count]] <- Ks2_y0
#   l_betamz_y0[[count]] <- betamz[ypos(y0, lat = lat)]
#   l_umz_y0[[count]] <- umz[ypos(y0, lat = lat)]
#
#   l_y1[[count]] <- ypos(y1, lat = lat)
#   l_lat_y1[[count]] <- y1
#   l_tun_y1[[count]] <- ifelse(l2_y1 <= 0, -1, 1)
#   l_l2_y1[[count]] <- l2_y1
#   l_Ks2_y1[[count]] <- Ks2_y1
#   l_betamz_y1[[count]] <- betamz[ypos(y1, lat = lat)]
#   l_umz_y1[[count]] <- umz[ypos(y1, lat = lat)]
#   break
# }
# C3 & C4: Ks2 < k2 --> l2 < 0
if(Ks2_y1  < 0 ) {
message(paste0("Stationary Rossby waves are only " ,
"possible for beta >=0 & U > 0 (HA1993). \n",
"Ks2 = ", Ks2_y1,"\n",
"l2 = ", l2_y1,"\n",
"l2[count-1] = ", l_l2_y1[count-1],"\n",
"Leaving parent while loop 1"))
break
}
# Write the elements at y0 on the lists
l_time[[count]] <- count
l_y0[[count]] <- ypos(y0, lat = lat)
l_lon_x0[[count]] <- x0
l_lat_y0[[count]] <- y0
l_tun_y0[[count]] <- ifelse(l2_y0 <= 0, -1, 1)
l_l2_y0[[count]] <- l2_y0
l_Ks2_y0[[count]] <- Ks2_y0
l_betamz_y0[[count]] <- betamz[ypos(y0, lat = lat)]
l_umz_y0[[count]] <- umz[ypos(y0, lat = lat)]
# Write the elements at y1 on the lists
l_y1[[count]] <- ypos(y1, lat = lat)
l_lat_y1[[count]] <- y1
l_tun_y1[[count]] <- ifelse(l2_y1 <= 0, -1, 1)
l_l2_y1[[count]] <- l2_y1
l_Ks2_y1[[count]] <- Ks2_y1
l_betamz_y1[[count]] <- betamz[ypos(y1, lat = lat)]
l_umz_y1[[count]] <- umz[ypos(y1, lat = lat)]
ug1 <- calcUg(betamz = betamz, Ks2 = Ks2_y1, y = y1, lat = lat)
vg1 <- calcVg(betamz = betamz, Ks2 = Ks2_y1, y = y1, lat = lat,
K = K, direction = direction, tl = -1)
x2 <- x0 + 0.5*dt*(ug0+ug1)
y2 <- y0 + 0.5*dt*(vg0+vg1)
# Leave the while parent loop 2 when x & y differences are almost 0
# The wave will stop propagating from this point
if(abs(x0 - x2) < 2e-13 & abs(y0 - y2) < 2e-13) {
message(paste0("|x0 - x2| & |y0 - y2| differences are almost 0 --> ",
"The wave is not propagating. \n",
"Leaving parent while loop 2\n"))
break
}
x0 <- x2
y0 <- y2
if(count == itime) {
message("\nitime reached \n",
"Leaving parent while loop 2\n")
break
}
}
# Store data after turning latitude
dff2 <- data.frame(K = rep(K, length(unlist(l_time))),
x_ini = rep(x_ini, length(unlist(l_time))),
y_ini = rep(y_ini, length(unlist(l_time))),
direction = rep(direction, length(unlist(l_time))),
time = unlist(l_time),
x0 = unlist(l_lon_x0),
y0 = unlist(l_lat_y0),
y1 = unlist(l_lat_y1),
ilat_y0 = unlist(l_y0),
ilat_y1 = unlist(l_y1),
tun_y0 = unlist(l_tun_y0),
tun_y1 = unlist(l_tun_y1),
l2_y0 = unlist(l_l2_y0),
l2_y1 = unlist(l_l2_y1),
l2_y0_rounded = round(unlist(l_l2_y0), 13),
l2_y1_rounded = round(unlist(l_l2_y1), 13),
Ks2_y0 = unlist(l_Ks2_y0),
Ks2_y1 = unlist(l_Ks2_y1),
betamz_y0 = unlist(l_betamz_y0),
betamz_y1 = unlist(l_betamz_y1),
umz_y0 = unlist(l_umz_y0),
umz_y1 = unlist(l_umz_y1))
dff2$id <- (0:(nrow(dff2) - 1))*-1
# write.csv(x = dff2, "K3_depois_tl.csv", row.names = FALSE)
DF <- rbind(dff, dff2)
# # # PARA PLOTAR K = 4 e dt = 12
DF <- DF[DF$l2_y0_rounded > 1e-13,]
# PARA PLOTAR K = 3 e dt = 12 e dt 6h
# Filter turning latitudes
# DF <- DF[DF$l2_y0_rounded > 1e-13 &
#            DF$l2_y1_rounded > 1e-13, ]
DF$hora <- rep(1:2, nrow(DF))[1:nrow(DF)]
DF <- DF[DF$hora == 1,]
# Add points to the graph
DF$x00 <- DF$x0 - 360
pontos <- sf::st_as_sf(DF, coords = c("x00", "y0"), crs = 4326)
# Calculate Great Circle for ray tracing
r <- ray_path(DF$x0 - 360, DF$y0)
DF <- sf::st_sf(DF, geometry = r)
# Simple plot
plot(DF$geometry, axes = TRUE, main = paste0("K = ", K, "   dt = ", dt/60/60, "h"))
plot(pontos$geometry, add = TRUE, pch = 16, cex = 2)
path <- "/home/amanda/Documents/2020_AUSTRALIA/teste_raytracing/ma2005"
write_sf(obj = DF, paste0(path, "/DF_linhas_K",K,".shp"))
write_sf(obj = DF, paste0(path, "/DF_pontos_K",K,".shp"))
# mapWorld <- map_data('world')
# ggplot() +
#   geom_polygon(data = mapWorld, aes(x=long, y = lat, group = group)) +
#   geom_sf(data = DF)
y= -30
library(raytracing)
# K = 3
# itime = 10 * 4
# x0 = -130 + 360
# y0 = -30
# dt = 6 * 60 * 60
# direction = -1
# tl = 1
# a = 6371000
# verbose = FALSE
# MAGANA & AMBRIZZI 2005 ####
input <- system.file("extdata",
"uwnd.mon.mean_300hPa_1997-98DJF.nc",
package = "raytracing")
b <- betaks(ifile = input)
betamz = colMeans(b$betam, na.rm = TRUE)
umz = colMeans(b$um, na.rm = TRUE)
mediaz = umz
73/2
tlat = 73
n <- trunc(tlat/2)
n
# Calcular os coeficientes A, am e bm (modificados):
A <- mediaz[tlat]
A
mediaz
mediaz[tlat]
lam <-list()
lbm <-list()
for(i in 1:n){
A <- sum(A, mediaz[i], mediaz[i + n], na.rm = TRUE)
am <- 0
bm <- 0
for (j in 1:tlat) {
yk <- mediaz[j]
xkm <- 2*pi*i*(j-1)/(2*n + 1)
am <- sum(am, yk*cos(xkm), na.rm = TRUE)
bm <- sum(bm, yk*sin(xkm), na.rm = TRUE)
}
lam[[i]] <- am
lbm[[i]] <- bm
} # Aqui termina o FOUR1
A
lA <- list()
for(i in 1:n){
A <- sum(A, mediaz[i], mediaz[i + n], na.rm = TRUE)
am <- 0
bm <- 0
for (j in 1:tlat) {
yk <- mediaz[j]
xkm <- 2*pi*i*(j-1)/(2*n + 1)
am <- sum(am, yk*cos(xkm), na.rm = TRUE)
bm <- sum(bm, yk*sin(xkm), na.rm = TRUE)
}
# Escreve os valores calculados no loop nas suas listas
lA[[i]] <- A
lam[[i]] <- am
lbm[[i]] <- bm
} # Aqui termina o FOUR1
# Funcao para obter o dado na lat desejada
somatorio <- 0
somatorio
lami <- unlist(lam)
lbmi <- unlist(lbm)
lami
lbmi
for(k in 1:n){
x <- pi*(90 - y)/180  # D
somatorio <- sum(somatorio,
lami[k]*cos(2*x*k),
lbmi[k]*sin(2*x*k),
na.rm = TRUE)
}
(A + 2*somatorio)/(2*n+1)
2.20363e+12
round(2.20363e+12)
round(2.20363e+12,10)
round(2.20363e+12,12)
round(2.20363e+12,13)
round(2.20363e+12,10)
round(2.20363e+12,9)
# Interpolação trigonometrica
it <- function(y, mediaz, tlat){
n <- trunc(tlat/2)
# Calcular os coeficientes A, am e bm (modificados):
A <- mediaz[tlat]
lA <- list()
lam <-list()
lbm <-list()
for(i in 1:n){
A <- sum(A, mediaz[i], mediaz[i + n], na.rm = TRUE)
am <- 0
bm <- 0
for (j in 1:tlat) {
yk <- mediaz[j]
xkm <- 2*pi*i*(j-1)/(2*n + 1)
am <- sum(am, yk*cos(xkm), na.rm = TRUE)
bm <- sum(bm, yk*sin(xkm), na.rm = TRUE)
}
# Escreve os valores calculados no loop nas suas listas
lA[[i]] <- A
lam[[i]] <- am
lbm[[i]] <- bm
} # Aqui termina o FOUR1
# Funcao para obter o dado na lat desejada
somatorio <- 0
lami <- unlist(lam)
lbmi <- unlist(lbm)
for(k in 1:n){
x <- pi*(90 - y)/180  # D
somatorio <- sum(somatorio,
lami[k]*cos(2*x*k),
lbmi[k]*sin(2*x*k),
na.rm = TRUE)
}
(A + 2*somatorio)/(2*n+1)
}
it(y = 30, mediaz = umz, tlat = 73)
# Interpolação trigonometrica
it <- function(y, mediaz, tlat){
n <- trunc(tlat/2)
# Calcular os coeficientes A, am e bm (modificados):
A <- mediaz[tlat]
lA <- list()
lam <-list()
lbm <-list()
for(i in 1:n){
A <- sum(A, mediaz[i], mediaz[i + n], na.rm = TRUE)
am <- 0
bm <- 0
for (j in 1:tlat) {
yk <- mediaz[j]
xkm <- 2*pi*i*(j-1)/(2*n + 1)
am <- sum(am, yk*cos(xkm), na.rm = TRUE)
bm <- sum(bm, yk*sin(xkm), na.rm = TRUE)
}
# Escreve os valores calculados no loop nas suas listas
lA[[i]] <- A
lam[[i]] <- am
lbm[[i]] <- bm
} # Aqui termina o FOUR1
# Funcao para obter o dado na lat desejada
somatorio <- 0
lAi <- unlist(lA)
lami <- unlist(lam)
lbmi <- unlist(lbm)
for(k in 1:n){
x <- pi*(90 - y)/180  # D
somatorio <- sum(somatorio,
lami[k]*cos(2*x*k),
lbmi[k]*sin(2*x*k),
na.rm = TRUE)
}
(lAi + 2*somatorio)/(2*n+1)
}
it(y = 30, mediaz = umz, tlat = 73)
length(b$lat)
nlat/2
nlat <- length(b$lat)
nlat/2
trunc(nlat/2)
n <- trunc(nlat/2)
umz
umz[nlat]
for (i in 1:n) {
A0 <- A0 + umz[i] + umz[i + n]
}
# Calc parameter A
A0 <- umz[nlat] # Primeiro valor de AO
for (i in 1:n) {
A0 <- A0 + umz[i] + umz[i + n]
}
A0
# Calc parameter A
A0 <- NA # Primeiro valor de AO
for (i in 1:n) {
A0 <- A0 + umz[i] + umz[i + n]
}
A0
# Calc parameter A
A0 <- 0 # Primeiro valor de AO
for (i in 1:n) {
A0 <- A0 + umz[i] + umz[i + n]
}
A0
for (i in 1:n) {
A0 <- umz[i] + umz[i + n]
}
A0
umz
round(umz)
round(umz, 2)
round(umz, 1)
round(umz, 3)
round(umz, 4)
round(umz)
# Calc parameter A
A0 <- umz
A0
# Calc parameter A
A0 <- umz[n]
A0
n
umz[nlat]
A0 <- umz[nlat]
A0 <- A0 + umz[1] + umz[1 + 36]
A0 <- A0 + umz[2] + umz[2 + 36]
A0 <- A0 + umz[3] + umz[3 + 36]
A0 <- A0 + umz[4] + umz[4 + 36]
A0 <- A0 + umz[5] + umz[5 + 36]
A0 <- A0 + umz[6] + umz[6 + 36]
A0 <- A0 + umz[7] + umz[7 + 36]
A0 <- A0 + umz[8] + umz[8 + 36]
A0
# Calc parameter A
A0 <- 0
A0 <- A0 + umz[1] + umz[1 + 36]
A0 <- A0 + umz[2] + umz[2 + 36]
A0 <- A0 + umz[3] + umz[3 + 36]
A0 <- A0 + umz[4] + umz[4 + 36]
A0 <- A0 + umz[5] + umz[5 + 36]
A0 <- A0 + umz[6] + umz[6 + 36]
A0 <- A0 + umz[7] + umz[7 + 36]
A0 <- A0 + umz[8] + umz[8 + 36]
A0
# Calc parameter A
A0 <- 0
A0
umz[1]
umz[1 + 36]
round(1.640385e+14, 14)
round(1.640385e+14, 15
)
trunc(1.640385e+14)
trunc(1.640385e+14,1)
umz[36 + 36]
umz[36] + umz[36 + 36]
